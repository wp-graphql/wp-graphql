<?php

class AssertValidSchemaTest extends \Codeception\TestCase\WPTestCase {

	public function setUp(): void {
		$settings = get_option( 'graphql_general_settings' );
		$settings['public_introspection_enabled'] = 'on';
		update_option( 'graphql_general_settings', $settings );
		WPGraphQL::clear_schema();
		parent::setUp(); // TODO: Change the autogenerated stub

	}

	public function tearDown(): void {
		// your tear down methods here

		// then
		\WPGraphQL::clear_schema();
		parent::tearDown();

	}

	public function testValidSchema() {
		$this->assertTrue( true );
	}

	// Validate schema.
	public function testSchema() {
		try {
			$request = new \WPGraphQL\Request();
			$request->schema->assertValid();

			// Assert true upon success.
			$this->assertTrue( true );
		} catch (\GraphQL\Error\InvariantViolation $e) {
			// use --debug flag to view.
			codecept_debug( $e->getMessage() );

			// Fail upon throwing
			$this->assertTrue( false );
		}
	}

	public function testIntrospectionQueriesDisabledForPublicRequests() {

		add_filter( 'graphql_debug_enabled', '__return_false' );

		$settings = get_option( 'graphql_general_settings' );
		$settings['public_introspection_enabled'] = 'off';
		update_option( 'graphql_general_settings', $settings );

		$actual = graphql([
			'query' => '
			{
			  __type(name: "RootQuery") {
			    name
			  }
			  __schema {
			    queryType {
			      name
			    }
			  }
			}
			'
		]);

		codecept_debug( $actual );

		$this->assertArrayHasKey( 'errors', $actual );
		$this->assertSame( 'GraphQL introspection is not allowed, but the query contained __schema or __type', $actual['errors'][0]['message'] );

	}

	public function testIntrospectionQueriesByAdminWhenPublicIntrospectionIsDisabled() {

		$settings = get_option( 'graphql_general_settings' );
		$settings['public_introspection_enabled'] = 'off';
		update_option( 'graphql_general_settings', $settings );

		$admin = $this->factory()->user->create( [
			'role' => 'administrator'
		] );

		wp_set_current_user( $admin );

		$actual = graphql([
			'query' => '
			{
			  __type(name: "RootQuery") {
			    name
			  }
			  __schema {
			    queryType {
			      name
			    }
			  }
			}
			'
		]);

		codecept_debug( $actual );

		$this->assertArrayNotHasKey( 'errors', $actual );

	}

	public function testIntrospectionQueriesEnabledForPublicUsers() {

		$settings = get_option( 'graphql_general_settings' );
		$settings['public_introspection_enabled'] = 'on';
		update_option( 'graphql_general_settings', $settings );

		$actual = graphql([
			'query' => '
			{
			  __type(name: "RootQuery") {
			    name
			  }
			  __schema {
			    queryType {
			      name
			    }
			  }
			}
			'
		]);

		codecept_debug( $actual );

		$this->assertArrayNotHasKey( 'errors', $actual );

	}

	public function testContentTypesOfTaxonomy() {

		register_post_type( 'test_content_type', [
			'show_in_graphql' => true,
			'graphql_single_name' => 'TestContentType',
			'graphql_plural_name' => 'TestContentTypes',
			'public' => true,
			'label' => 'Test Content Type, Yo'
		] );

		register_post_type( 'not_in_graphql', [
			'public' => true,
		] );

		register_taxonomy( 'test_taxonomy', [ 'test_content_type', 'not_in_graphql' ], [
			'show_in_graphql' => true,
			'graphql_single_name' => 'TestTaxonomy',
			'graphql_plural_name' => 'TestTaxonomies',
			'public' => true,
			'label' => 'Test Taxonomy, Yo'
		]);

		register_post_type( 'not_in_graphql', [
			'public' => true,
			'label' => 'Not in GraphQL Test'
		] );

		register_taxonomy( 'test_taxonomy_two', [ 'not_in_graphql' ], [
			'show_in_graphql' => true,
			'graphql_single_name' => 'TestTaxonomyTwo',
			'graphql_plural_name' => 'TestTaxonomieTwos',
			'public' => true,
			'label' => 'Test Taxonomy Two, Yo'
		]);

		$query = '
		query GetEnum($name:String!){
		  __type(name: $name) {
		    name
		    kind
		    enumValues {
		      name
		    }
		  }
		}
		';

		$variables = [
			'name' => "ContentTypesOfTestTaxonomyEnum"
		];

		$actual = graphql([
			'query' => $query,
			'variables' => $variables,
		]);

		// We registered a Taxonomy that is associated with 2 post types. One that is shown in GraphQL, and one that is not
		// So we Introspect the taxonomy and assert that the enum is created with the association to the post type that
		// is shown in GraphQL but excludes the other post type
		$this->assertArrayNotHasKey( 'errors', $actual );
		$this->assertTrue( 1 === count( $actual['data']['__type']['enumValues'] ) );
		$this->assertSame( \WPGraphQL\Type\WPEnumType::get_safe_name( 'test_content_type' ), $actual['data']['__type']['enumValues'][0]['name'] );

		$variables = [
			'name' => "ContentTypesOfTestTaxonomyTwoEnum"
		];

		$actual = graphql([
			'query' => $query,
			'variables' => $variables,
		]);

		// We registered another taxonomy that is only associated with a post type that is not shown in graphql,
		// so we introspect to test that a "ContentTypesOfTestTaxonomyTwoEnum" isn't actually
		// registered to the Schema
		$this->assertNull( $actual['data']['__type'] );

	}

	public function testSchemaSupportsLazyLoadingTypes() {
		add_filter( 'graphql_get_type', function ( $type, $type_name ) {
			if ( 'TestLazyType' === $type_name ) {
				// Should not be called since this type does not need to be loaded.
				$this->assertTrue( false );
			}

			return $type;
		}, 10, 2 );

		add_filter( 'graphql_wp_object_type_config', function ( $config ) {
			if ( 'TestLazyType' === $config['name'] ) {
				// Should not be called since this type does not need to be loaded.
				$this->assertTrue( false );
			}

			return $config;
		}, 10, 1 );

		add_filter( 'graphql_object_fields', function ( $fields, $type_name ) {
			if ( 'TestLazyType' === $type_name ) {
				// Should not be called since this type does not need to be loaded.
				$this->assertTrue( false );
			}

			return $fields;
		}, 10, 2 );

		register_graphql_type(
			'TestLazyType',
			[
				'fields' => function () {
					// Should not be called since this type does not need to be loaded.
					$this->assertTrue( false );

					return [];
				},
			]
		);

		register_graphql_field(
			'RootQuery',
			'example',
			[ 'type' => 'TestLazyType' ]
		);

		register_graphql_field(
			'RootQuery',
			'allExamples',
			[
				'type' => [
					'list_of' => [
						'non_null' => 'TestLazyType',
					],
				],
			],
		);

		$actual = graphql([
			'query' => '
			{
				__type(name: "RootQuery") {
					name
				}
			}
			',
		]);

		codecept_debug( $actual );

		$this->assertArrayNotHasKey( 'errors', $actual );
	}

	public function testSchemaCallsLazyLoadingTypesWhenNeeded() {
		$filter_calls = [];

		add_filter( 'graphql_get_type', function ( $type, $type_name ) use ( &$filter_calls ) {
			if ( 'TestLazyType' === $type_name ) {
				$filter_calls[] = 'graphql_get_type';
			}

			return $type;
		}, 10, 2 );

		add_filter( 'graphql_wp_object_type_config', function ( $config ) use ( &$filter_calls ) {
			if ( 'TestLazyType' === $config['name'] ) {
				$filter_calls[] = 'graphql_wp_object_type_config';
			}

			return $config;
		}, 10, 1 );

		add_filter( 'graphql_object_fields', function ( $fields, $type_name ) use ( &$filter_calls ) {
			if ( 'TestLazyType' === $type_name ) {
				$filter_calls[] = 'graphql_object_fields';
			}

			return $fields;
		}, 10, 2 );

		register_graphql_type(
			'TestLazyType',
			[
				'fields' => [
					'foo' => [
						'type'    => 'String',
					],
				],
			]
		);

		register_graphql_field(
			'RootQuery',
			'example',
			[
				'type' => 'TestLazyType',
				'resolve' => function () {
					return [
						'foo' => 'bar',
					];
				},
			]
		);

		$actual = graphql( [
			'query' => '
			{
				example {
					foo
				}
			}
			',
		] );

		codecept_debug( $actual );

		$this->assertArrayNotHasKey( 'errors', $actual );
		$this->assertSame( 'bar', $actual['data']['example']['foo'] );

		$expected_filter_calls = [ 'graphql_wp_object_type_config', 'graphql_object_fields', 'graphql_get_type' ];
		$this->assertSame( $expected_filter_calls, $filter_calls );
	}
}
